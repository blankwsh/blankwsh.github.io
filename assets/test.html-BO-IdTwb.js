import{_ as t,r as e,o,c as p,a,b as l,d as c,e as n}from"./app-DHHNIcXM.js";const i={},r=n(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h2 id="简答题" tabindex="-1"><a class="header-anchor" href="#简答题"><span>简答题</span></a></h2><h3 id="_1-介绍一下-jdk、jre、jvm-是什么-它们之间有什么关系" tabindex="-1"><a class="header-anchor" href="#_1-介绍一下-jdk、jre、jvm-是什么-它们之间有什么关系"><span><strong>1. 介绍一下 JDK、JRE、JVM 是什么，它们之间有什么关系</strong></span></a></h3><p>JDK 就是 Java SE Development Kit，即 Java 标准版开发包，它提供了编译和运行 Java 程序所需要的各种资源和工具，包括常用的 Java 类库、Java 编译器和 Java 运行时环境。（注：JDK=JRE+java、javac 这些开发工具）</p><p>JRE 就是 Java Runtime Environment，即 Java 运行时环境，JRE 是 JDK 的一部分，用于解释执行 Java 的字节码文件。如果只需要运行 Java 程序，则只需要下载 JRE；如果需要开发 Java 程序，则需要下载 JDK。（注：JRE=JVM+System 等核心类库）</p><p>JVM 就是 Java Virtual Machine，即 Java 虚拟机，JVM 是 JRE 的一部分，它是 Java 实现跨平台最核心的部分，用于解释执行 Java 的字节码文件，是可以运行 Java 字节码文件的虚拟计算机。</p><hr class="color"><h3 id="_2-什么是方法重写-什么是方法重载" tabindex="-1"><a class="header-anchor" href="#_2-什么是方法重写-什么是方法重载"><span><strong>2. 什么是方法重写，什么是方法重载</strong></span></a></h3><p>方法重写发生在存在继承关系的类或者存在实现关系的接口之间，方法重写需要方法在不同类之中，方法名一致，参数列表一致，子类（实现类）方法的访问修饰符权限大于或等于父类（接口），子类抛出的异常数应当少于或等于父类的，如果父类的返回值类型是基本数据类型，那么子类的返回值类型应当与父类的保持一致，如果父类的返回值类型是引用数据类型，那么子类的返回值类型的范围应当小于或等于父类的。私有方法、静态方法和最终方法都不能被重写。</p><p>方法重载需要方法在同一个类中，方法名一致，参数列表不同，与修饰符和返回值类型均无关。</p><hr class="color"><h3 id="_3-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_3-和-equals-的区别"><span><strong>3. ==和 equals 的区别</strong></span></a></h3><p>如果操作数是基本数据类型，那么==比较的是变量的值是否相等；如果操作数是引用数据类型，那么==比较的是变量的地址是否相等。</p><p>equals 在重写前默认比较的是变量的地址是否相等，重写后是根据重写的规则比较变量是否相等。常用类库里的 String、Date 和 Integer 的 equals 方法都已经被重写了，比较的是变量的值。</p><hr class="color"><h3 id="_4-string、stringbuffer-和-stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#_4-string、stringbuffer-和-stringbuilder-的区别"><span><strong>4. String、StringBuffer 和 StringBuilder 的区别</strong></span></a></h3><p>String 类是 final 类，其不可以被继承，String 类内部维护了一个字符数组常量<code>private final char[] value</code>记录 String 对象的值，因此一旦 String 类被实例化，其值就不可以被修改。</p><p>StringBuffer 类是 Java1.0 提供的类，用于对字符串进行动态的修改。其不是 final 类，对象的值由内部的<code>private transient char[] toStringCache</code>字符数组维护，这个值没有使用 final 修饰符进行修饰，因此，StringBuffer 对象的值是可变的。此外，StringBuffer 提供的字符串操作方法都使用了 synchronized 修饰符进行修饰，因此 StringBuffer 类是线程安全的，更适合在并发编程时使用。</p><p>StringBuilder 类是 Java1.5 提供的类，它兼容了 StringBuffer 类提供的 API，但它的成员方法没有使用 synchronized 修饰符进行修饰，因此其通常在单线程环境下使用，在单线程下性能更高。</p><p>String 可以通过 StringBuffer 和 StringBuilder 的构造器转换为 StringBuffer 和 StringBuilder，StringBuffer 和 StringBuilder 可以通过 toString()方法转换为 String。</p><hr class="color"><h3 id="_5-什么是单例模式-单例模式的常见实现方式有什么" tabindex="-1"><a class="header-anchor" href="#_5-什么是单例模式-单例模式的常见实现方式有什么"><span><strong>5. 什么是单例模式，单例模式的常见实现方式有什么</strong></span></a></h3><p>单例模式是指在程序运行时，一个类有且仅有一个实例。</p><p>单例模式的几个设计要点：私有化构造器；实例使用 static 修饰符确保实例共享；创建一个成员方法向外暴露实例。</p><p>单例模式的常见实现方式有六种，分别是饿汉式（对象在类加载时就创建完毕）、懒汉式（使用对象时对象才被创建）、懒汉加锁（获取实例的成员方法加锁）、懒汉双重检查锁（当实例为 null 时，使用锁创建实例，且在锁里需要再判断一次实例是否为 null）、静态内部类实现、枚举实现。</p><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 饿汉式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 懒汉式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 懒汉加锁</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 懒汉双重检查锁</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">// volatile的两个作用：1. 保证变量的可见性 2. 禁止指令重排序（这里主要是禁止了重排序，可见性由synchronized实现了）</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 外层的检查会出现指令重排序的问题</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 内层的检查是为了防止多个线程创建多个对象</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>`,29),d={class:"hint-container tip"},u=n('<p class="hint-container-title">提示</p><p>原始的懒汉式单例在多线程环境下存在两个主要问题：</p><ol><li><p>多个线程会创建出多个对象</p></li><li><p>new 操作不是原始操作，某一线程的指令重排序导致另一个线程访问到未初始化完全的 instance 对象</p></li></ol><p>为了解决问题 1，我们可以使用 synchronized 修饰获取实例的方法，这就是懒汉加锁。懒汉加锁在多线程环境下确实能确保线程安全，但是每次访问实例时都需要进行同步（尽管实例已经被创建），因此性能上会有所降低。</p><p>因此我们可以使用 synchronized 同步块包裹需要同步的代码，不需要同步的代码不上锁，此时由于判断语句被放入到同步块中，所以每次获取实例时仍需要执行同步块，因此我们可以在同步块之外添加一个判断语句，这也就是双重检查。此时当线程判断出对象已经被创建就会直接返回对象，无需执行同步块的内容，提高了性能。</p><p>由于使用了 synchronized 同步块，只有一个线程可以拿到锁执行创建对象的代码，自然而然地解决了问题 1。由于 new 操作不是原子操作，假设一个线程在执行 instance = new Singleton() 语句时出现了指令重排序的问题，此时另一个线程执行了外层的判断语句，那么这个线程就会访问到未初始化完全的对象，因此还需要解决问题 2。</p><p>可以使用 volatile 修饰符修饰对象，被修饰的对象在创建时就不会出现指令重排序的问题，这样其他线程也就不会访问到因为指令重排序而产生的未初始化完全的对象了。这样我们就解决了原始的懒汉式单例存在的两个问题。</p><p>当一个线程执行 instance = new Singleton() 语句时，由于 new 操作不是原子操作，可能会出现指令重排序，导致以下情况发生：</p><ol><li><p>分配内存空间给 instance</p></li><li><p>在内存中初始化 instance</p></li><li><p>将 instance 指向分配的内存空间</p></li></ol><p>如果指令重排序，可能会导致第 3 步在第 2 步之前执行，此时其他线程可能会访问到一个未初始化完全的 instance，从而导致程序出现错误。</p><p>使用 volatile 关键字修饰 instance 变量可以防止指令重排序，确保在多线程环境下，其他线程能够正确地看到 instance 的初始化过程。这样就可以避免了由于指令重排序带来的线程安全问题。</p>',11),k={href:"https://blog.csdn.net/weixin_44471490/article/details/108929289",target:"_blank",rel:"noopener noreferrer"},h=n(`<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 静态内部类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 枚举实现，枚举项都是常量，枚举的构造器都是私有的，符合单例设计的设计思路</span>
<span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    instance
<span class="token punctuation">}</span>
</code></pre></div><hr class="color"><h3 id="_6-抽象类和接口有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-抽象类和接口有什么区别"><span><strong>6. 抽象类和接口有什么区别</strong></span></a></h3><ol><li>继承的角度：一个抽象类只能继承一个类，一个接口可以继承多个接口</li><li>构造器的角度：抽象类可以有构造器但不可以直接实例化，接口不允许有构造器</li><li>成员变量的角度：抽象类可以有各种访问修饰符的变量，接口只能有常量（public final static）且常量修饰符默认自带可以省略</li><li>成员方法的角度：抽象类可以同时拥有抽象方法和实例方法，接口只能有抽象方法，且修饰符默认为 public abstract 可以省略（不考虑 JDK8 新增的默认方法、静态方法和私有方法）</li><li>使用方法的角度：抽象类需要被子类继承，接口需要被实现类实现</li><li>设计用途的角度：抽象类描述一种类的继承关系，提供一些共同的属性和行为，是 is-a 的关系，接口描述一种能力或行为，不在意实现的细节，而强调实现类必须实现这些方法，是 has-a 的关系。</li></ol><hr class="color"><h3 id="_7-什么是冒泡排序-手写一下" tabindex="-1"><a class="header-anchor" href="#_7-什么是冒泡排序-手写一下"><span><strong>7. 什么是冒泡排序，手写一下</strong></span></a></h3><p>冒泡排序可以分为两个步骤：</p><ol><li>从第一个元素开始，依次比较相邻的两个元素，如果前一个元素大于后一个元素，则交换它们的位置，这样较大的元素就会“冒泡”到序列的末尾。</li><li>继续对剩下的元素重复上述比较和交换步骤，直到所有元素都排好序为止。</li></ol><div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 有多少个元素就遍历几次数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 每次遍历时不需要与已经排序好的元素进行比较</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr class="color"><h3 id="_8-list、map-和-set-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8-list、map-和-set-有什么区别"><span><strong>8. List、Map 和 Set 有什么区别</strong></span></a></h3><ol><li>List 和 Set 都是单列集合 Collection 的子接口，Map 则是双列集合的接口。</li><li>List 是有序、元素可重复、有索引的，Set 是无序、元素不可重复、无索引的，Map 是无序、键不可重复、无索引的。</li><li>List 接口常用的实现类有 ArrayList、LinkedList。ArrayList 底层是基于数组实现的，因此查找快增删慢；LinkedList 底层是基于双链表实现的，因此增删快查找慢。</li><li>Set 接口常用的实现类有 TreeSet 和 HashSet。TreeSet 底层是基于红黑树实现的，因此 TreeSet 是可排序的，可以通过实现 Comparable 接口或者创建比较器 Comparator 来实现元素的排序；HashSet 底层是基于哈希表实现的（数组+链表+红黑树），因此 HashSet 在增删改查的性能表现都不错，HashSet 是通过重写 hashCode()方法和 equals()方法确定元素在哈希表中存储的位置的。</li><li>Map 接口常用的实现类有 TreeMap 和 HashMap，部分 Set 底层是通过 Map 来实现的，如 HashSet 的底层是基于 HashMap 实现的，TreeSet 的底层是基于 TreeMap 实现的。</li></ol><hr class="color"><h3 id="_9-arraylist-和-linkedlist-有什么区别" tabindex="-1"><a class="header-anchor" href="#_9-arraylist-和-linkedlist-有什么区别"><span><strong>9. ArrayList 和 LinkedList 有什么区别</strong></span></a></h3><ol><li>先说两者的共同作用：ArrayList 和 LinkedList 都是实现了 List 接口的容器类，用于存储一系列的对象引用，并且可以对容器元素进行增删改查操作。</li><li>再说区别：ArrayList 是基于动态数组实现的，因此 ArrayList 支持随机访问，可以通过索引直接查找元素，查找元素的时间复杂度为 O(1)，但是 ArrayList 在列表中间插入或删除元素时需要多次移动元素，耗时较大。 LinkedList 是基于双向链表实现的，因此 LinkedList 在插入和删除元素时只需要调整链表的指针，不需要像 ArrayList 那样频繁地移动元素，增删元素的效率高，但是 LinkedList 不支持随机访问，访问元素必须从头到尾遍历整个链表，时间复杂度为 O(n)。此外，ArrayList 的空间浪费体现在 ArrayList 的结尾需要预留一定的容量空间，而 LinkedList 的则体现在 LinkedList 的每一个元素都需要占用较大的空间。</li></ol><hr class="color"><h3 id="_10-创建线程的方式有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_10-创建线程的方式有哪些-有什么区别"><span><strong>10. 创建线程的方式有哪些，有什么区别</strong></span></a></h3><ol><li>继承 Thread 类并重写 run 方法，由于类只支持单继承，因此这种创建线程的方式的可扩展性较差。</li><li>实现 Runnable 接口并重写 run 方法，避免了单继承的局限性，降低了耦合度，但是重写的 run 方法不能抛出异常（Runnable 接口中的 public abstract void run();方法没有抛出异常）且不能有返回值。</li><li>实现 Callable 接口并重写 call 方法，这种方式可以有返回值且可以抛出异常（Callable 接口中的 public abstract V call() throws Exception;方法抛出了异常），返回值的类型由 Callable 接口的泛型指定。</li><li>使用 Executors 工具类创建线程池，Executors.newFixedThreadPool(int nThreads)用于创建一个线程数量固定的线程池，使用 submit 方法提交 Runnable 和 Callable 任务。（其他线程池见下表）</li></ol><table><thead><tr><th>线程池类</th><th>说明</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建一个线程池，它重用<strong>固定数量</strong>的线程，这些线程基于<strong>共享的无界队列</strong>运行。在任何时刻，最多有 nThreads 个线程处于活动状态来处理任务。如果在所有线程都处于活动状态时提交了额外的任务，它们将在队列中等待，直到有线程可用。如果任何线程在关闭之前由于执行期间的异常而终止，那么如果需要执行后续任务，将会有一个新线程取代它。线程池中的线程将存在直到显式调用 shutdown 方法。</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个线程池，<strong>根据需要创建新线程</strong>，但<strong>在可用时将重用先前构造的线程</strong>。这些线程池通常可以<strong>提高执行许多短暂异步任务的程序的性能</strong>。对 execute 的调用将重用先前构造的线程（如果可用）。如果没有现有线程可用，则将创建一个新线程并添加到线程池中。未被使用的线程将在六十秒后被终止并从缓存中移除。因此，长时间空闲的线程池将不会消耗任何资源。</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建一个使用单个工作线程和无界队列的执行器。然而，需要注意的是，如果此单线程在关闭之前由于执行期间的异常而终止，那么如果需要执行后续任务，将会有一个新线程取代它。任务被保证按顺序执行，并且在任何给定时间内最多只有一个任务处于活动状态。与 newFixedThreadPool(1)不同，返回的执行器保证不可重新配置为使用额外的线程。</td></tr><tr><td>newSingleThreadScheduledExecutor()</td><td>创建一个单线程的执行器，可以在给定延迟后调度命令运行，或者定期执行。但是需要注意，如果此单线程在关闭之前由于执行期间的故障而终止，那么如果需要执行后续任务，将会有一个新线程取代它。任务被保证按顺序执行，并且任何给定时间内最多只会有一个任务处于活动状态。与 newScheduledThreadPool(1)不同，返回的执行器保证不可重新配置为使用额外的线程。</td></tr><tr><td>newScheduledThreadPool(int corePoolSize)</td><td>创建一个可以在给定延迟后调度命令运行，或定期执行的线程池。</td></tr><tr><td>newWorkStealingPool(int parallelism)</td><td>这个方法创建了一个线程池，维护足够数量的线程来支持给定的并行级别，并可能使用多个队列来减少争用。并行度水平对应于同时处于活动状态的线程数量，或者可以参与任务处理的线程数量。实际线程数量可以动态增长和缩减。工作窃取线程池不对提交的任务执行顺序做任何保证。如果参数为空时，默认将并行级别设置为当前系统的 CPU 核心数量的两倍</td></tr></tbody></table><ol><li>使用 ThreadPoolExecutor 创建自定义线程池，ThreadPoolExecutor 的构造器接收七个参数，分别是 <ul><li>int corePoolSize，表示核心线程数；</li><li>int maximumPoolSize，表示最大线程数；</li><li>long keepAliveTime，表示临时线程的最大存活时间；</li><li>TimeUnit unit，参数三的单位；</li><li>BlockingQueue&lt;Runnable&gt; workQueue，表示等待队列，常使用 new ArrayBlockingQueue&lt;&gt;(int length)，ArrayBlockingQueue 是一个有界等待队列，接收的参数表示该有界等待队列的长度；</li><li>ThreadFactory threadFactory，表示线程工厂，常使用 Executors 工具类的 defaultThreadFactory 方法创建线程工厂；</li><li>RejectedExecutionHandler handler，表示拒绝策略，ThreadPoolExecutor 类提供了多种拒绝策略（以静态内部类的形式定义），如下表所示。</li></ul></li></ol><table><thead><tr><th>拒绝策略</th><th>说明</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy</td><td>丢弃任务并抛出 RejectedExecutionException 异常。是默认的策略</td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy</td><td>丢弃任务，但是不抛出异常</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>抛弃队列中等待最久的任务 然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由主线程负责调用任务的 run()方法从而绕过线程池直接执行</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当任务数小于等于核心线程数时，所有任务都由核心线程执行；当任务数大于核心线程数时，超过的任务将会在等待队列中等待；当等待队列满了后，线程池会根据指定的最大线程数创建临时线程执行任务；当任务数大于最大线程数+等待队列长度时，执行拒绝策略。</p></div><hr class="color"><h3 id="_11-调用-start-和-run-方法的区别" tabindex="-1"><a class="header-anchor" href="#_11-调用-start-和-run-方法的区别"><span><strong>11. 调用 start 和 run 方法的区别</strong></span></a></h3><p>如果直接调用一个线程的 run 方法，该方法会在当前线程中被执行，而不是启动一个新线程，这样做实际上就是普通的方法调用。</p><p>如果调用一个线程的 start 方法，该方法会启动该线程，并在新线程中执行 run 方法。start 方法负责线程启动前的一些准备工作，run 方法执行实际的任务。</p><hr class="color"><h3 id="_12-简述一下线程的生命周期-线程的各种状态之间是如何转换的" tabindex="-1"><a class="header-anchor" href="#_12-简述一下线程的生命周期-线程的各种状态之间是如何转换的"><span><strong>12. 简述一下线程的生命周期，线程的各种状态之间是如何转换的</strong></span></a></h3><p>线程的生命周期是指线程从创建到销毁的整个过程，线程在整个生命周期中有六种状态，这些状态以枚举项的形式存储在 Thread 类的 State 枚举中，分别是：NEW、RUNNABLE、BLOCKED、WAITTING、TIMED_WATTING 和 TERMINATED。</p><div class="hint-container tip"><p class="hint-container-title">各种状态的文档注释说明</p><ul><li>NEW: Thread state for a thread which has not yet started.</li><li>NEW: 还未启动的线程处于 NEW 状态。</li><li>RUNNABLE: Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</li><li>RUNNABLE: 一个正在运行的线程处于 RUNNABLE 状态。一个处于 RUNNABLE 状态的线程正在 Java 虚拟机中执行，但它可能在等待来自操作系统的其他资源，比如处理器。</li><li>BLOCKED: Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/ method or reenter a synchronized block/ method after calling <code>Object.wait</code>.</li><li>BLOCKED: 一个正在等待获取一个监视器锁的线程处于 BLOCKED 状态。等待获取监视器锁是为了进入同步块/方法或在调用<code>Object.wait</code>后重新进入同步块/方法。</li><li>WAITTING: Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods: <code>Object.wait</code> with no timeout; <code>Thread.join</code> with no timeout; <code>LockSupport.park</code>. A thread in the waiting state is waiting for another thread to perform a particular action. For example, a thread that has called <code>Object.wait()</code> on an object is waiting for another thread to call <code>Object.notify()</code> or <code>Object.notifyAll()</code> on that object. A thread that has called <code>Thread.join()</code> is waiting for a specified thread to terminate.</li><li>WAITTING: 一个正在等待的线程处于 WAITTING 状态。一个线程处于等待状态是因为调用了这些方法：没有设置超时时间的<code>Object.wait</code>；没有设置超时时间的<code>Thread.join</code>；<code>LockSupport.park</code>。一个线程处于等待状态是为了等待另一个线程完成某个任务。比如，一个调用了<code>Object.wait()</code>的线程是在等待另一个线程调用<code>Object.notify()</code>或者<code>Object.notifyAll()</code>唤醒它。一个调用了<code>Thread.join()</code>的线程是在等待一个特定的线程进入终止状态。</li><li>TIMED_WAITING: Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of the following methods with a specified positive waiting time: <code>Thread.sleep</code>; <code>Object.wait</code> with timeout; <code>Thread.join</code> with timeout; <code>LockSupport.parkNanos</code>; <code>LockSupport.parkUntil</code>.</li><li>TIMED_WAITING: 一个正在等待且有指定等待时间的线程处于 TIMED_WAITING 状态。一个线程处于计时等待状态是因为调用了这些方法且指定了等待时间：<code>Thread.sleep</code>；有超时时间的<code>Object.wait</code>；有超时时间的<code>Thread.join</code>；<code>LockSupport.parkNanos</code>；<code>LockSupport. parkUntil</code>。</li><li>TERMINATED: Thread state for a terminated thread. The thread has completed execution.</li><li>TERMINATED: 一个终止了的线程处于 TERMINATED 状态。当线程处于 TERMINATED 状态时，表示该线程已经执行完毕。</li></ul></div><p>NEW -&gt; RUNNABLE : 调用 start 方法</p><p>RUNNABLE -&gt; BLOCKED : 进入同步块/同步方法时没能抢到锁</p><p>BLOCKED -&gt; RUNNABLE : 抢到锁</p><p>RUNNABLE -&gt; WAITTING : 调用 Object.wait()或者 Thread.join()</p><p>WAITTING -&gt; RUNNABLE : 调用 Object.notify()或者 Object.notifyAll()，同时抢到锁</p><p>WAITTING -&gt; BLOCKED : 调用 Object.notify()或者 Object.notifyAll()，但没有抢到锁</p><p>RUNNABLE -&gt; TIMED_WAITTING : 调用 Thread.sleep()或者 Object.wait()或者 Thread.join()且设置了超时时间</p><p>TIMED_WAITTING -&gt; RUNNABLE : 达到超时时间且抢到锁/未到超时时间但调用了 Object.notify()或者 Object.notifyAll()且抢到锁</p><p>TIMED_WAITTING -&gt; BLOCKED : 达到超时时间但没抢到锁/未到超时时间但调用了 Object.notify()或者 Object.notifyAll()但没抢到锁</p><p>RUNNABLE -&gt; TERMINATED : run 方法调用完毕后/调用 stop 方法（stop 方法已过时）</p><hr class="color"><h3 id="_13-线程相关的方法有哪些" tabindex="-1"><a class="header-anchor" href="#_13-线程相关的方法有哪些"><span><strong>13. 线程相关的方法有哪些</strong></span></a></h3><ol><li>start：启动线程，虚拟机在新线程中执行 run 方法</li><li>wait：让线程进入等待状态直至被唤醒</li><li>sleep：让线程进入一段时间的睡眠状态</li><li>yield：线程让步，当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。</li><li>interrupt：中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位，线程本身并不会因此而改变状态</li><li>notify：用于唤醒在对象监视器上等待的单个线程。它必须在同步代码块或同步方法中调用，并且只能由持有该对象监视器的线程调用</li><li>notifyAll：用于唤醒在对象监视器上等待的所有线程</li><li>join：等待其他线程终止</li></ol><hr class="color"><h3 id="_14-wait-和-sleep-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_14-wait-和-sleep-方法有什么区别"><span><strong>14. wait 和 sleep 方法有什么区别</strong></span></a></h3><ol><li>从线程状态转换的角度看，没有设置超时时间的 wait 方法会使线程进入 WAITTING 状态，设置了超时时间的 wait 方法和 sleep 方法会使线程进入 TIMED_WAITTING 状态。</li><li>从方法归属者的角度来看，wait 方法是 Object 类的成员方法，sleep 方法是 Thread 类的成员方法。</li><li>从使用范围的角度来看，wait 方法只能在同步块或者同步方法中使用，sleep 方法可以在任何地方被使用。</li><li>从锁的释放来看，调用 wait 方法的线程在等待过程中会释放锁资源，调用 sleep 方法的线程则不会释放锁资源。</li><li>从捕获异常的角度来看，wait 方法不需要捕获异常，sleep 方法需要捕获 InterruptedException 异常。</li></ol><hr class="color"><h3 id="_15-网络的七层架构" tabindex="-1"><a class="header-anchor" href="#_15-网络的七层架构"><span><strong>15. 网络的七层架构</strong></span></a></h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><hr class="color"><h3 id="_16-udp-和-tcp-的区别是什么-都有什么应用场景" tabindex="-1"><a class="header-anchor" href="#_16-udp-和-tcp-的区别是什么-都有什么应用场景"><span><strong>16. UDP 和 TCP 的区别是什么，都有什么应用场景</strong></span></a></h3><ol><li>UDP 是无连接的协议，TCP 是面向连接的协议，也就是说客户端和服务端通过 TCP 协议进行通信前必须先建立连接，建立连接的过程被称为三次握手。</li><li>UDP 是不可靠的，数据报包在传输过程中会出现丢失现象，TCP 提供交付保证，如果消息在传输过程中丢失，TCP 会重发该消息。</li><li>UDP 传输的消息可能是无序的，TCP 会对无序的消息进行排序，确保消息的有序性。</li><li>UDP 的传输速度较快，因为 UDP 是无连接且不可靠的，TCP 的传输速度较慢，因为 TCP 是面向连接且提供交付保证的。</li><li>TCP 有流量控制和拥塞控制，UDP 则没有。</li><li>UDP 是面向报文的协议，每个数据报都是记录型的数据报，接收端可以识别到数据报的边界（水池），TCP 是面向流的协议，无边界记录（水流）。</li><li>UDP 可以单播、组播和广播，TCP 只能单播。</li><li>UDP 是轻量级的协议，数据报的报头固定为 8 个字节，TCP 是重量级的协议，数据报的报头至少为 20 个字节。</li></ol><p>UDP 适用于效率要求相对高、准确性要求相对低的场景，如视频通话、网络直播等，TCP 适用于效率要求相对低、准确性要求相对高的场景，如文件下载、扫码支付等。</p><hr class="color"><h3 id="_17-get-和-post-有什么区别" tabindex="-1"><a class="header-anchor" href="#_17-get-和-post-有什么区别"><span><strong>17. GET 和 POST 有什么区别</strong></span></a></h3><ul><li>从安全性的角度看，GET 请求传输的数据会以查询字符串的形式附加在 URL 的末尾，传输的数据直接可见；POST 请求传输的数据被保存在请求体中，传输的数据不易暴露。</li><li>从传输数据量的角度看，由于 GET 请求传输的数据会附加在 URL 的末尾，而浏览器对 URL 长度的会有所限制，因此 GET 请求传输的数据量取决于浏览器对 URL 长度的限制，不同浏览器对 URL 的长度有不同的标准，通常情况下 GET 请求可以传输的数据量为 1KB 到 18KB；如果浏览器和服务器没有对请求体的大小作出明确的要求，那么 POST 请求传输的数据量可以视为不受限制的。</li><li>从传输时使用的字符集的角度看，由于 URL 中只能出现 ASCII 字符，因此 GET 请求在处理表单提交的数据时需要将其中的非 ASCII 字符转换为 ASCII 字符；POST 请求则没有这种限制，支持整个 ISO10646 字符集。</li><li>从执行效率的角度看，GET 请求的执行效率会略比 POST 请求的高。</li><li>从缓存的角度看，GET 请求可以被缓存，被书签和浏览器历史记录保存，POST 请求则不可以。</li><li>从 RESTful 风格的 API 设计角度来看，GET 通常用于发送查询数据请求，POST 通常用于发送增加数据请求。</li></ul><hr class="color"><h3 id="_18-什么是-ajax-ajax-有什么优点" tabindex="-1"><a class="header-anchor" href="#_18-什么是-ajax-ajax-有什么优点"><span><strong>18. 什么是 AJAX，AJAX 有什么优点</strong></span></a></h3><p>AJAX（Asynchronous JavaScript and XML）是一种用于在不刷新整个页面的情况下，通过后台与服务器进行数据交换，更新部分页面的网页开发技术。</p><p>AJAX 的优点有：</p><ul><li>异步通信：用户可以在等待服务器响应时继续与网页进行交互，提高了用户体验。</li><li>增量加载：通过 AJAX 可以不刷新整个页面的情况下更新部分数据，提高了网页的加载速度。</li><li>减少带宽占用：服务端和客户端之间的数据传输量降低。</li></ul><hr class="color"><h3 id="_19-完整的-sql-查询语句是怎么样的" tabindex="-1"><a class="header-anchor" href="#_19-完整的-sql-查询语句是怎么样的"><span><strong>19. 完整的 SQL 查询语句是怎么样的</strong></span></a></h3><p>完整的 SQL 查询语句为<code>select * from 主表 on 表连接条件 left/right join 外表 where 查询条件 group by 分组条件 count(*)等聚合函数 having 分组后的查询条件 order by 排序方式 limit 分页条件</code>。</p><ul><li>聚合函数：常用的聚合函数有 count、sum、min、max 和 avg。</li><li>排序方式：有升序（asc）和降序（desc），其中升序为默认值，可以省略。</li><li>limit 关键字是 MySQL 的方言，limit a, b 表示从查询后的第 a+1 条数据开始，将查询数据分为 b 页。</li></ul><hr class="color"><h3 id="_20-mybatis-中的-和-有什么区别" tabindex="-1"><a class="header-anchor" href="#_20-mybatis-中的-和-有什么区别"><span><strong>20. MyBatis 中的#{}和\${}有什么区别</strong></span></a></h3><p>#{}为占位符，MyBatis 在预编译处理时会将#{}替换为?，调用 PreparedStatement 的 set 方法进行赋值；\${}为字符串替换，MyBatis在预编译处理时会将\${}替换为变量的值。使用#{}可以有效防止 SQL 注入，提高了系统的安全性。</p><hr class="color"><h3 id="_21-javaweb-的常用组件有哪些-作用是什么" tabindex="-1"><a class="header-anchor" href="#_21-javaweb-的常用组件有哪些-作用是什么"><span><strong>21. JavaWeb 的常用组件有哪些，作用是什么</strong></span></a></h3><p>JavaWeb 的常用组件有 Servlet、Filter 和 Listener。</p><ul><li>Servlet 用于处理 Web 应用程序中的 HTTP 请求和生成 HTTP 响应。Servlet 可以通过继承<code>javax.servlet.http.HttpServlet</code>类或者实现<code>javax.servlet.Servlet</code>接口来创建。</li><li>Filter 用于拦截 Web 应用程序中的 HTTP 请求和响应，对其进行预处理、后处理或修改。Filter 通过实现<code>javax.servlet.Filter</code>接口来创建，并重写 doFilter()方法以实现过滤逻辑。</li><li>Listener 用于监听 Web 应用程序中的事件和对象的创建、销毁以及属性变化等。Listener 通过实现<code>javax.servlet.ServletContextListener</code>、<code>javax.servlet.ServletRequestListener</code>等接口来创建，并实现相应的方法。</li></ul><hr class="color"><h3 id="_22-synchronized-的底层实现原理是怎么样的" tabindex="-1"><a class="header-anchor" href="#_22-synchronized-的底层实现原理是怎么样的"><span><strong>22. synchronized 的底层实现原理是怎么样的</strong></span></a></h3><p>synchronized 是 Java 的一个关键字，用于修饰方法或代码块实现</p><hr class="color"><h3 id="_23-springboot-有什么优点" tabindex="-1"><a class="header-anchor" href="#_23-springboot-有什么优点"><span><strong>23. SpringBoot 有什么优点</strong></span></a></h3><ul><li>简化配置：SpringBoot 采用了约定大于配置的理念，通过默认配置和自动配置来减少开发人员的配置工作。它可以自动配置大部分常见的应用程序组件，从而简化了项目的配置和搭建过程。</li><li>内嵌式容器：SpringBoot 内置了常用的 Servlet 容器（如 Tomcat 等），使得应用程序打包成可执行的 JAR 文件，无需部署到外部的 Web 服务器，从而简化了部署和交付流程。</li><li>自动化依赖管理：SpringBoot 通过其依赖管理机制，可以自动管理和升级项目中所需的依赖库。开发人员只需指定所需的依赖，SpringBoot 就能够自动下载、配置和管理这些依赖。</li></ul><hr class="color"><h3 id="_24-事务的四大特性" tabindex="-1"><a class="header-anchor" href="#_24-事务的四大特性"><span><strong>24. 事务的四大特性</strong></span></a></h3><ol><li>原子性（Atomicity）：事务是一个不可分割的工作单位，要么全部成功完成，要么全部失败回滚，不存在部分执行的情况。原子性确保了数据的一致性，即数据库在任何时刻都处于一致的状态。</li><li>一致性（Consistency）：事务在执行前后，数据库从一个一致的状态转变为另一个一致的状态。这意味着事务必须满足所有的约束，包括完整性约束、关系约束等，以保持数据的完整性和一致性。</li><li>隔离性（Isolation）：多个事务并发执行时，各个事务之间应该相互隔离，一个事务的执行不应该影响其他事务的执行。隔离性确保了事务的并发执行不会产生数据不一致的问题，避免了脏读、不可重复读、幻读等并发问题。</li><li>持久性（Durability）：一旦事务提交，其结果应该是永久性的，即使系统发生故障，数据也不应该丢失。持久性保证了事务对数据的修改是持久的，即使系统重启或崩溃，数据也能够被恢复到事务提交后的状态。</li></ol><hr class="color">`,83);function g(y,w){const s=e("ExternalLinkIcon");return o(),p("div",null,[r,a("div",d,[u,a("p",null,[a("a",k,[l("详细分析"),c(s)])])]),h])}const v=t(i,[["render",g],["__file","test.html.vue"]]),b=JSON.parse('{"path":"/test/test.html","title":"Java","lang":"zh-CN","frontmatter":{},"headers":[{"level":1,"title":"Java","slug":"java","link":"#java","children":[{"level":2,"title":"简答题","slug":"简答题","link":"#简答题","children":[]}]}],"git":{},"filePathRelative":"test/test.md"}');export{v as comp,b as data};
